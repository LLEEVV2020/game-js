<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Beat ’em up JS Tutor (с комментариями)</title>
    <style>
        /* ============ БАЗОВЫЕ СТИЛИ И ОФОРМЛЕНИЕ ============ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            /* Выравниваем контейнер по центру экрана */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Градиентный фон */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: Arial, Helvetica, sans-serif;
            color: #fff;
            overflow: hidden
        }

        /* Контейнер игры: рамка и тень */
        #gameContainer {
            position: relative;
            border: 5px solid #e94560;
            box-shadow: 0 0 30px rgba(233, 69, 96, .5)
        }

        /* Канвас — поле игры с фоновым градиентом */
        canvas {
            display: block;
            background: linear-gradient(180deg, #0f3460 0%, #1a1a2e 100%)
        }

        /* Верхний левый HUD: HP, Score, Wave, Combo */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, .8);
            z-index: 10
        }

        #ui .row {
            margin-bottom: 4px
        }

        /* Экран Game Over по центру */
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #e94560;
            font-size: 42px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, .9);
            display: none;
            /* Скрываем до поражения */
            z-index: 30
        }

        #gameOver button {
            margin-top: 16px;
            padding: 12px 24px;
            font-size: 18px;
            background: #e94560;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: .3s
        }

        #gameOver button:hover {
            background: #ff6b81;
            transform: scale(1.08)
        }

        /* Подсказка управления внизу слева */
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, .6);
            padding: 8px;
            border-radius: 6px;
            z-index: 10
        }

        /* Правый обучающий блок с вопросами по JS */
        #taskPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 360px;
            z-index: 20;
            background: rgba(0, 0, 0, .6);
            border: 1px solid rgba(255, 255, 255, .2);
            border-radius: 10px;
            padding: 12px
        }

        #taskTitle {
            font-weight: bold;
            margin-bottom: 6px;
            color: #ffda79
        }

        /* Заголовок */
        #taskText {
            font-size: 14px;
            line-height: 1.35;
            margin-bottom: 8px
        }

        /* Текст задания */

        /* Строка с темой и прогрессом внутри taskPanel */
        #topicRow {
            font-size: 12px;
            opacity: .9;
            margin-top: 6px
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 255, 255, .1);
            margin-right: 6px;
            margin-top: 4px
        }

        /* Поле ввода ответа + кнопки */
        #answerRow {
            display: flex;
            gap: 6px;
            margin-top: 6px
        }

        #answer {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, .2);
            background: rgba(255, 255, 255, .1);
            color: #fff;
            outline: none
        }

        #checkBtn,
        #skipBtn {
            padding: 8px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold
        }

        #checkBtn {
            background: #20bf6b;
            color: #fff
        }

        /* Проверить */
        #skipBtn {
            background: #57606f;
            color: #fff;
            margin-left: 6px
        }

        /* Пропустить */

        /* Обратная связь под ответом */
        #feedback {
            min-height: 20px;
            margin-top: 6px;
            font-size: 13px
        }

        .ok {
            color: #2ed573
        }

        /* Верно */
        .bad {
            color: #ff6b81
        }

        /* Неверно */
        .hint {
            color: #ffd32a
        }

        /* Подсказка */
    </style>
</head>

<body>
    <div id="gameContainer">
        <!-- Канвас — игровое поле -->
        <canvas id="gameCanvas" width="900" height="600"></canvas>

        <!-- Левый верхний HUD -->
        <div id="ui">
            <div class="row">HP: <span id="health">100</span></div>
            <div class="row">Score: <span id="score">0</span></div>
            <div class="row">Wave: <span id="wave">1</span></div>
            <div class="row">Combo: <span id="combo">0</span></div>
        </div>

        <!-- Панель заданий по JS (справа) -->
        <div id="taskPanel">
            <div id="taskTitle">Задание</div> <!-- Заголовок задания -->
            <div id="taskText"></div> <!-- Текст вопроса -->
            <div id="topicRow">
                Тема: <span id="topicBadge" class="badge"></span> <!-- Название темы -->
                Прогресс: <span id="topicProgress" class="badge">0%</span> <!-- Процент по теме -->
            </div>
            <div id="answerRow">
                <input id="answer" placeholder="Ваш ответ..." /> <!-- Поле ответа -->
                <button id="checkBtn">Check</button> <!-- Проверить -->
                <button id="skipBtn" title="Пропустить, -10 очков">Skip</button> <!-- Пропустить -->
            </div>
            <div id="feedback"></div> <!-- Обратная связь (верно/неверно/подсказки) -->
        </div>

        <!-- Подсказки по управлению -->
        <div id="controls">
            WASD — движение | SPACE — удар | J — прыжок | Enter — проверить ответ
        </div>

        <!-- Экран Game Over -->
        <div id="gameOver">
            <div>GAME OVER!</div>
            <div style="font-size: 22px; margin-top: 6px;">Score: <span id="finalScore">0</span></div>
            <button id="restartBtn">Restart</button>
        </div>
    </div>

    <script>
        /* ============================================================
           =============== ОСНОВНЫЕ ССЫЛКИ НА DOM/КАНВАС ===============
           ============================================================ */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        /* ============================================================
           ===================== СОСТОЯНИЕ ИГРЫ ========================
           ------------------------------------------------------------
           - gameState хранит общий прогресс и параметры ритма игры
           - running: флаг работы цикла
           - score: очки
           - wave: волна сложности (возрастает с побеждёнными врагами)
           - enemiesDefeated: счётчик побеждённых врагов
           - combo: серия правильных ответов подряд
           - slowFactor: множитель скорости врагов (замедляем во время ответа)
           ============================================================ */
        let gameState = {
            running: true,
            score: 0,
            wave: 1,
            enemiesDefeated: 0,
            combo: 0,
            slowFactor: 1,
        };

        /* ============================================================
           ========================= ИГРОК ============================
           ------------------------------------------------------------
           - x,y,width,height: прямоугольник игрока
           - vx,vy: скорости по осям
           - speed/jump/g: параметры движения
           - onGround: стоит ли на земле
           - hp/maxHp: здоровье
           - attacking/atkCd: состояние атаки и её перезарядка
           - dir: направление (1 вправо, -1 влево)
           - color: цвет тела (для прямоугольника)
           ============================================================ */
        const player = {
            x: 120, y: 420, width: 42, height: 64,
            vx: 0, vy: 0, speed: 5, jump: 15, g: 0.8,
            onGround: true, hp: 100, maxHp: 100,
            attacking: false, atkCd: 0, dir: 1, color: '#00ff9d'
        };

        /* Линия земли по оси Y (ниже — коллизия по «ногам») */
        const groundY = 480;

        /* ============================================================
           ======================== ВРАГИ =============================
           ------------------------------------------------------------
           - enemies: массив врагов
           - lastSpawn: время последнего спауна (для частоты появления)
           - baseSpawn: базовая задержка спауна в мс (уменьшается по волнам)
           ============================================================ */
        let enemies = [];
        let lastSpawn = 0;
        const baseSpawn = 1800;

        /* ============================================================
           ======================== ЧАСТИЦЫ ===========================
           ------------------------------------------------------------
           - Простейшая система частиц (эффекты ударов, попаданий)
           ============================================================ */
        let particles = [];

        /* ============================================================
           ======================== ВВОД КЛАВИАТУРЫ ===================
           ------------------------------------------------------------
           - keys: объект состояния клавиш по символьно
           - Enter привязан к проверке ответа
           ============================================================ */
        const keys = {};
        addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Enter') checkAnswer(); // Enter проверяет ответ
        });
        addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        /* ============================================================
           ==================== ПУЛ ЗАДАНИЙ ПО JS =====================
           ------------------------------------------------------------
           - topics: массив тем; каждая тема содержит массив items:
             { q: 'вопрос', a: 'правильный ответ', norm?: функция нормализации }
           - Изменяйте/дополняйте вопросы тут.
           - norm — опциональная функция, приводящая ответ к виду
             (например, к нижнему регистру), чтобы сравнение было корректнее.
           ============================================================ */
        const topics = [
            {
                id: 'variables',
                title: 'Переменные',
                items: [
                    { q: 'Чему будет равно x после: let x = 2; x += 3; ?', a: '5' },
                    { q: 'typeof null ?', a: 'object', norm: v => v.toLowerCase() },
                    { q: 'let a=1; const b="2"; a+b = ?', a: '12' },
                ]
            },
            {
                id: 'types',
                title: 'Типы и сравнения',
                items: [
                    { q: 'true == "1" ?', a: 'true', norm: v => v.toLowerCase() },
                    { q: '0 == false ?', a: 'true', norm: v => v.toLowerCase() },
                    { q: '0 === false ?', a: 'false', norm: v => v.toLowerCase() },
                ]
            },
            {
                id: 'arrays',
                title: 'Массивы',
                items: [
                    { q: '[1,2,3].push(4); длина?', a: '4' },
                    { q: '[1,2,3].map(x=>x*2)[1] = ?', a: '4' },
                    { q: '[1,2,3].filter(x=>x>1).length = ?', a: '2' },
                ]
            },
            {
                id: 'functions',
                title: 'Функции',
                items: [
                    { q: '(function(){return 3})()', a: '3' },
                    { q: 'let f=a=>a+2; f(5)=?', a: '7' },
                    { q: 'Арность функции (x,y,z)=>x ?', a: '3' },
                ]
            },
            {
                id: 'conditions',
                title: 'Условия',
                items: [
                    { q: 'x=5; результат x>3?"A":"B" ?', a: 'A', norm: v => v.toUpperCase() },
                    { q: 'x=0; !!x ?', a: 'false', norm: v => v.toLowerCase() },
                    { q: 'x=undefined; x??"ok" ?', a: 'ok', norm: v => v.toLowerCase() },
                ]
            },
            {
                id: 'loops',
                title: 'Циклы',
                items: [
                    { q: 'let s=0; for(let i=0;i<3;i++) s+=i; s=?', a: '3' },
                    { q: '[..."hi"].length = ?', a: '2' },
                    { q: 'for..of по "ab": последняя буква?', a: 'b' },
                ]
            },
            {
                id: 'objects',
                title: 'Объекты',
                items: [
                    { q: 'let o={a:1}; "a" in o ?', a: 'true', norm: v => v.toLowerCase() },
                    { q: 'JSON.parse("1") тип?', a: 'number', norm: v => v.toLowerCase() },
                    { q: 'Object.keys({a:1,b:2}).length = ?', a: '2' },
                ]
            },
            {
                id: 'strings',
                title: 'Строки',
                items: [
                    { q: '"a"+"b".toUpperCase() = ?', a: 'aB' },
                    { q: '"Hello".slice(1,3)= ?', a: 'el' },
                    { q: '"foo".includes("o") ?', a: 'true', norm: v => v.toLowerCase() },
                ]
            },
            {
                id: 'this',
                title: 'this и стрелочные',
                items: [
                    { q: 'typeof (()=>{}).prototype ?', a: 'undefined', norm: v => v.toLowerCase() },
                    { q: 'this в стрелке берётся из?', a: 'контекста', norm: v => v.toLowerCase() },
                    { q: 'obj.m.call(null) — this = ?', a: 'null', norm: v => v.toLowerCase() },
                ]
            },
            {
                id: 'closures',
                title: 'Замыкания',
                items: [
                    { q: 'Функция, хранящая доступ к внешним переменным — это?', a: 'замыкание', norm: v => v.toLowerCase() },
                    { q: 'let x=1; function f(){return x} f()=?', a: '1' },
                    { q: 'let add=n=>m=>n+m; add(2)(3)=?', a: '5' },
                ]
            },
            {
                id: 'prototypes',
                title: 'Прототипы',
                items: [
                    { q: 'Object.getPrototypeOf({}) === Object.prototype ?', a: 'true', norm: v => v.toLowerCase() },
                    { q: '[].__proto__ === Array.prototype ?', a: 'true', norm: v => v.toLowerCase() },
                    { q: 'new Date() instanceof Object ?', a: 'true', norm: v => v.toLowerCase() },
                ]
            },
            {
                id: 'async',
                title: 'Промисы/async',
                items: [
                    { q: 'Promise.resolve(1).then(x=>x+1) -> значение в then?', a: '2' },
                    { q: 'await 5 возвращает?', a: '5' },
                    { q: 'setTimeout(...,0) — попадает в?', a: 'macrotask', norm: v => v.toLowerCase() },
                ]
            },
        ];

        /* Прогресс по каждой теме: сколько выполнено из общего количества */
        const topicProgress = Object.fromEntries(
            topics.map(t => [t.id, { done: 0, total: t.items.length }])
        );

        /* ============================================================
           =============== ЛОГИКА ВЫБОРА И ПРОВЕРКИ ЗАДАНИЙ ===========
           ------------------------------------------------------------
           - currentTopic/currentTask: выбранная тема и текущий вопрос
           - wrongStreak: серия ошибок подряд (для подсказок)
           - pickTopic(): выбирает тему (менее пройденную; с волной — сложнее)
           - pickTaskFrom(topic): выбирает следующий вопрос из темы
           - loadNewTask(): загружает вопрос в UI и включает замедление боя
           - isCorrect/normalize: безопасное сравнение ответов
           - checkAnswer(): обработка ответа пользователя
           - makeHint(): простые подсказки по ключевым словам
           ============================================================ */
        let currentTopic = null;
        let currentTask = null;
        let wrongStreak = 0;

        // Утилита короткого селектора
        const $ = sel => document.querySelector(sel);
        // Ссылки на элементы панели задач
        const taskText = $('#taskText');
        const taskTitle = $('#taskTitle');
        const topicBadge = $('#topicBadge');
        const topicProgressEl = $('#topicProgress');
        const feedback = $('#feedback');
        const answerInput = $('#answer');
        const checkBtn = $('#checkBtn');
        const skipBtn = $('#skipBtn');

        // Выбор темы: смещаемся к более сложным темам с ростом wave
        function pickTopic() {
            const wave = gameState.wave;
            // biasIndex выбирает, сколько тем доступно (растёт с wave)
            const biasIndex = Math.min(topics.length - 1, Math.floor((wave - 1) / 2));
            const candidates = topics.slice(0, Math.max(4, biasIndex + 1));
            // Сортируем по проценту выполнения — сначала менее пройденные
            candidates.sort((a, b) => {
                const pa = topicProgress[a.id].done / topicProgress[a.id].total;
                const pb = topicProgress[b.id].done / topicProgress[b.id].total;
                return pa - pb;
            });
            return candidates[0];
        }

        // Берём либо следующий невыполненный вопрос, либо случайный (когда тема закрыта)
        function pickTaskFrom(topic) {
            const prog = topicProgress[topic.id];
            if (prog.done >= prog.total) {
                // Всё выполнено — возвращаем случайный вопрос для повторения
                return topic.items[Math.floor(Math.random() * topic.items.length)];
            }
            // Невыполненные идут по порядку
            return topic.items[prog.done];
        }

        // Загружаем новый вопрос в UI
        function loadNewTask() {
            currentTopic = pickTopic();
            currentTask = pickTaskFrom(currentTopic);

            // Обновляем UI панели задания
            taskTitle.textContent = 'Задание';
            taskText.textContent = currentTask.q;
            topicBadge.textContent = currentTopic.title;
            const prog = topicProgress[currentTopic.id];
            topicProgressEl.textContent = Math.round((prog.done / prog.total) * 100) + '%';

            // Сбрасываем обратную связь и поле ввода
            feedback.textContent = '';
            feedback.className = '';
            answerInput.value = '';
            answerInput.focus();

            // Замедляем врагов, пока игрок думает/печатает
            gameState.slowFactor = 0.5;
        }

        // Нормализация введённого значения и правильного ответа (обрезка/регистр)
        function normalize(v, task) {
            const s = (v ?? '').toString().trim();
            if (task.norm) return task.norm(s);
            return s;
        }

        // Сравнение ответов после нормализации
        function isCorrect(user, task) {
            return normalize(user, task) === normalize(task.a, task);
        }

        // Награды за верный ответ: урон ближайшему врагу, очки, комбо-баффы
        function grantRewards() {
            // Находим ближайшего врага по |x - player.x|
            const nearest = enemies.slice().sort((a, b) => Math.abs(a.x - player.x) - Math.abs(b.x - player.x))[0];

            // Базовый урон растёт с волной
            let damage = 35 + gameState.wave * 3;

            // Бафф от комбо (ограничен 10)
            const combo = Math.min(10, gameState.combo);
            damage += combo * 4;

            // Очки за ответ + бонус за комбо
            gameState.score += 50 + combo * 10;

            if (nearest) {
                // Применяем урон и лёгкий отбрасывающий эффект
                nearest.hp -= damage;
                createParticles(nearest.x + nearest.width / 2, nearest.y + nearest.height / 2, '#ffe66d');
                nearest.x += Math.sign(nearest.x - player.x) * 20;
            } else {
                // Если врагов нет — чуть лечим игрока
                player.hp = Math.min(player.maxHp, player.hp + 5);
            }

            // Каждые 3 комбо — временный буст скорости движения игрока
            if (gameState.combo > 0 && gameState.combo % 3 === 0) {
                player.speed = 6.5;
                setTimeout(() => player.speed = 5, 2000); // 2 сек буста
            }
        }

        // Наказание за неверный ответ: урон игроку, враги замедляются меньше
        function applyPenalty() {
            player.hp -= 6; // небольшой урон
            createParticles(player.x + player.width / 2, player.y + player.height / 2, '#ff6b81');
            // Чуть уменьшаем замедление (враги быстрее двигаются относительно ответа)
            const prev = gameState.slowFactor;
            gameState.slowFactor = Math.max(0.4, prev - 0.1);
        }

        // Проверка ответа с UI-обратной связью
        function checkAnswer() {
            if (!currentTask) return;
            const val = answerInput.value;

            if (isCorrect(val, currentTask)) {
                // Верный ответ
                feedback.textContent = 'Верно!';
                feedback.className = 'ok';
                wrongStreak = 0;
                gameState.combo += 1;

                // Отмечаем прогресс по теме (только если ещё не закрыта)
                const prog = topicProgress[currentTopic.id];
                if (prog.done < prog.total) prog.done += 1;

                // Выдать награды (урон врагу/очки/баффы)
                grantRewards();

                // Быстрый переход к следующему вопросу
                setTimeout(loadNewTask, 300);
            } else {
                // Неверный ответ
                wrongStreak += 1;
                gameState.combo = 0;
                feedback.textContent = 'Нет, попробуйте ещё';
                feedback.className = 'bad';

                applyPenalty(); // урон игроку и «почти обычная скорость» врагов

                // После 2 ошибок показываем подсказку
                if (wrongStreak >= 2) {
                    const hint = makeHint(currentTask);
                    if (hint) {
                        const div = document.createElement('div');
                        div.className = 'hint';
                        div.textContent = 'Подсказка: ' + hint;
                        feedback.appendChild(div);
                    }
                }
            }
        }

        // Простые подсказки по ключевым словам из текста вопроса
        function makeHint(task) {
            const q = task.q.toLowerCase();
            if (q.includes('typeof null')) return 'Историческая особенность языка — это не "null".';
            if (q.includes('==') && !q.includes('===')) return 'При == происходит приведение типов.';
            if (q.includes('arrow') || q.includes('стрел')) return 'Стрелочные не имеют собственного this.';
            if (q.includes('json.parse')) return 'Парс строки числа вернёт число.';
            if (q.includes('slice')) return 'slice(start, end) — end не включительно.';
            if (q.includes('settimeout')) return 'setTimeout идёт в очередь макрозадач (macrotask).';
            return '';
        }

        // Кнопки «Проверить» и «Пропустить»
        checkBtn.addEventListener('click', checkAnswer);
        skipBtn.addEventListener('click', () => {
            // Штраф за пропуск —10 очков, сброс комбо, сброс серии ошибок
            gameState.score = Math.max(0, gameState.score - 10);
            gameState.combo = 0;
            feedback.textContent = 'Пропущено (-10)';
            feedback.className = 'bad';
            wrongStreak = 0;
            loadNewTask();
        });

        /* ============================================================
           ===================== ИГРОК: ЛОГИКА/ОТРИСОВКА ==============
           ============================================================ */

        // Обновление состояния игрока (движение, прыжок, атака, физика)
        function updatePlayer() {
            // Сброс горизонтальной скорости, затем считываем A/D
            player.vx = 0;
            if (keys['a']) { player.vx = -player.speed; player.dir = -1; }
            if (keys['d']) { player.vx = player.speed; player.dir = 1; }

            // Прыжок на клавишу J — срабатывает, если на земле
            if (keys['j'] && player.onGround) {
                player.vy = -player.jump;
                player.onGround = false;
            }

            // Удар пробелом с перезарядкой
            if (keys[' '] && !player.attacking && player.atkCd <= 0) {
                player.attacking = true;
                player.atkCd = 18; // длительность/кд удара
                attackHit();       // Проверяем попадания по врагам
            }

            // Применяем скорости к позиции
            player.x += player.vx;
            player.y += player.vy;

            // Гравитация, когда в воздухе
            if (!player.onGround) player.vy += player.g;

            // Коллизия с землёй (по нижней грани)
            if (player.y + player.height >= groundY) {
                player.y = groundY - player.height;
                player.vy = 0;
                player.onGround = true;
            }

            // Ограничиваем по ширине экрана
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

            // Перезарядка/завершение атаки
            if (player.atkCd > 0) player.atkCd--;
            if (player.attacking && player.atkCd <= 0) player.attacking = false;
        }

        // Отрисовка игрока (прямоугольник-тело, «голова», глаза, ударная зона, полоска HP)
        function drawPlayer() {
            // Тело
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Голова (просто прямоугольник)
            ctx.fillStyle = '#ffcc00';
            ctx.fillRect(player.x + 6, player.y - 16, 30, 20);

            // Глаза
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x + 12, player.y - 12, 5, 5);
            ctx.fillRect(player.x + 25, player.y - 12, 5, 5);

            // Визуализация удара (полупрозрачный прямоугольник перед игроком)
            if (player.attacking) {
                ctx.fillStyle = 'rgba(255,255,0,.45)';
                const ax = player.dir === 1 ? player.x + player.width : player.x - 34;
                ctx.fillRect(ax, player.y + 10, 34, 22);
            }

            // Полоска HP над игроком
            ctx.fillStyle = '#ff3b3b';
            ctx.fillRect(player.x, player.y - 10, player.width, 5);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(player.x, player.y - 10, player.width * (player.hp / player.maxHp), 5);
        }

        // Проверка удара игрока: наносим урон врагам в зоне
        function attackHit() {
            const range = 62; // дальность по X
            // Левая граница зоны удара зависит от направления
            const ax = player.dir === 1 ? player.x + player.width : player.x - range;

            enemies.forEach(e => {
                const dx = e.x - ax;                 // горизонтальное смещение врага от зоны удара
                const dy = Math.abs(e.y - player.y); // проверка «приблизительной высоты» совпадения
                if (Math.abs(dx) < range && dy < 84) {
                    e.hp -= 14;                    // урон
                    e.x += player.dir * 16;          // отбрасывание
                    createParticles(e.x + e.width / 2, e.y + e.height / 2, '#ffff00'); // эффект частиц
                }
            });
        }

        /* ============================================================
           ===================== ВРАГИ: ЛОГИКА/ОТРИСОВКА ==============
           ============================================================ */

        // Создание одного врага (спаун с левой или правой стороны)
        function spawnEnemy() {
            const side = Math.random() > 0.5 ? 1 : -1;
            const hp = 40 + gameState.wave * 12;             // здоровье растёт с волной
            const speed = (1.1 + gameState.wave * 0.22);       // скорость растёт с волной
            return {
                x: side === 1 ? -60 : canvas.width + 60,         // старт за пределами экрана
                y: groundY - 54,
                width: 38, height: 54,
                hp, maxHp: hp,
                speed, dir: side, atkCd: 0,
                color: `hsl(${Math.random() * 360},70%,50%)`     // случайный цвет для разнообразия
            };
        }

        // Обновление всех врагов + периодический спаун
        function updateEnemies(ts) {
            // Чем выше волна, тем быстрее спаунятся враги (но есть минимум 700мс)
            const spawnRate = Math.max(700, baseSpawn - gameState.wave * 120);
            if (!lastSpawn || ts - lastSpawn > spawnRate) {
                enemies.push(spawnEnemy());
                lastSpawn = ts;
            }

            enemies.forEach((e, i) => {
                // Направление на игрока
                const dx = player.x - e.x;
                const dist = Math.abs(dx);

                // Во время ответа враги замедлены множителем slowFactor
                const factor = gameState.slowFactor;

                // Движение к игроку, если он не слишком близко
                if (dist > 50) {
                    e.x += Math.sign(dx) * e.speed * factor;
                    e.dir = Math.sign(dx);
                }

                // Атака по игроку на близкой дистанции по перезарядке
                if (dist < 60 && e.atkCd <= 0) {
                    player.hp -= 5; // урон игроку
                    e.atkCd = Math.max(45, 70 - gameState.wave * 2); // кд атаки уменьшается по мере волн
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, '#ff3b3b');
                }
                if (e.atkCd > 0) e.atkCd--;

                // Смерть врага: удаление, очки, прогресс волны, эффект частиц
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    gameState.score += 120;
                    gameState.enemiesDefeated++;
                    createParticles(e.x + e.width / 2, e.y + e.height / 2, e.color);

                    // Каждые 6 побеждённых — новая волна
                    if (gameState.enemiesDefeated % 6 === 0) {
                        gameState.wave++;
                        // После повышения волны немного уменьшаем замедление, чтобы игра ускорялась
                        gameState.slowFactor = 0.8;
                    }
                }
            });

            // Плавно возвращаем slowFactor к 1, если он был изменён
            gameState.slowFactor += (1 - gameState.slowFactor) * 0.01;
        }

        // Простая отрисовка врагов (тело, «голова», глаза, полоска HP)
        function drawEnemies() {
            enemies.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.fillRect(e.x, e.y, e.width, e.height);

                ctx.fillStyle = '#333';
                ctx.fillRect(e.x + 5, e.y - 12, 26, 16);

                ctx.fillStyle = '#ff0000';
                ctx.fillRect(e.x + 8, e.y - 8, 4, 4);
                ctx.fillRect(e.x + 20, e.y - 8, 4, 4);

                // Полоска HP над врагом
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(e.x, e.y - 8, e.width, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(e.x, e.y - 8, e.width * (e.hp / e.maxHp), 4);
            });
        }

        /* ============================================================
           ===================== ЧАСТИЦЫ: ЛОГИКА/РЕНДЕР ===============
           ============================================================ */

        // Создание N одинаковых по параметрам частиц
        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8, // разброс по X
                    vy: (Math.random() - 0.5) * 8, // разброс по Y
                    life: 28, color
                });
            }
        }

        // Обновляем частицы, гравитация + уменьшаем «жизнь»
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.28; // псевдо-гравитация
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // Рисуем частицы с уменьшением прозрачности к концу жизни
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 28;  // чем меньше life — тем прозрачнее
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
                ctx.globalAlpha = 1;
            });
        }

        /* ============================================================
           ======================== ФОН/ЗЕМЛЯ =========================
           ============================================================ */
        function drawBackground() {
            // Земля — прямоугольник снизу
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Линия земли
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
        }

        /* ============================================================
           ====================== HUD / UI ОБНОВЛЕНИЕ =================
           ============================================================ */
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, Math.round(player.hp));
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('combo').textContent = gameState.combo;
            // Прогресс по теме отображаем при загрузке вопроса (topicProgressEl)
        }

        /* ============================================================
           ======================== GAME OVER =========================
           ============================================================ */
        function checkGameOver() {
            // Если HP <= 0 — останавливаем игру и показываем экран поражения
            if (player.hp <= 0) {
                gameState.running = false;
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = gameState.score;
            }
        }

        // Перезапуск игры: сбрасываем все состояния к стартовым
        function restart() {
            // Игрок
            player.hp = 100;
            player.x = 120;
            player.y = 420;

            // Массивы игровых сущностей
            enemies = [];
            particles = [];

            // Общие стейты
            gameState = {
                running: true,
                score: 0,
                wave: 1,
                enemiesDefeated: 0,
                combo: 0,
                slowFactor: 1
            };

            // Сброс прогресса по темам
            Object.keys(topicProgress).forEach(id => topicProgress[id].done = 0);

            // Скрыть экран Game Over
            document.getElementById('gameOver').style.display = 'none';

            // Загрузить первый вопрос и запустить цикл
            loadNewTask();
            gameLoop();
        }
        document.getElementById('restartBtn').addEventListener('click', restart);

        /* ============================================================
           ======================== ГЛАВНЫЙ ЦИКЛ ======================
           ------------------------------------------------------------
           - gameLoop выполняется каждый кадр через requestAnimationFrame
           - Порядок:
             1) очистка канваса
             2) обновление логики
             3) отрисовка сущностей
             4) обновление UI
             5) проверка Game Over
           ============================================================ */
        function gameLoop(ts = 0) {
            if (!gameState.running) return; // если игра остановлена — ничего не делаем

            // 1) Очистка экрана
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2) Логика: фон/физика/враги/частицы
            drawBackground();
            updatePlayer();
            updateEnemies(ts);
            updateParticles();

            // 3) Отрисовка: игрок/враги/частицы
            drawPlayer();
            drawEnemies();
            drawParticles();

            // 4) HUD
            updateUI();

            // 5) Проверка окончания
            checkGameOver();

            // Запрос следующего кадра
            requestAnimationFrame(gameLoop);
        }

        /* ============================================================
           ======================= ИНИЦИАЛИЗАЦИЯ ======================
           ------------------------------------------------------------
           - Загружаем первый вопрос, запускаем игровой цикл
           ============================================================ */
        loadNewTask();
        gameLoop();
    </script>
</body>

</html>